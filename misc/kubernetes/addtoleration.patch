diff --git a/cmd/kube-apiserver/app/plugins.go b/cmd/kube-apiserver/app/plugins.go
index c685428..9d31a73 100644
--- a/cmd/kube-apiserver/app/plugins.go
+++ b/cmd/kube-apiserver/app/plugins.go
@@ -41,4 +41,5 @@ import (
 	_ "k8s.io/kubernetes/plugin/pkg/admission/securitycontext/scdeny"
 	_ "k8s.io/kubernetes/plugin/pkg/admission/serviceaccount"
 	_ "k8s.io/kubernetes/plugin/pkg/admission/storageclass/default"
+	_ "k8s.io/kubernetes/plugin/pkg/admission/addtoleration"
 )
diff --git a/plugin/pkg/admission/addtoleration/admission.go b/plugin/pkg/admission/addtoleration/admission.go
new file mode 100644
index 0000000..34a85ba
--- /dev/null
+++ b/plugin/pkg/admission/addtoleration/admission.go
@@ -0,0 +1,104 @@
+package addtoleration
+
+import (
+	"encoding/json"
+	"io"
+
+	"github.com/golang/glog"
+	"k8s.io/kubernetes/pkg/admission"
+	"k8s.io/kubernetes/pkg/api"
+	apierrors "k8s.io/kubernetes/pkg/api/errors"
+	clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
+	"k8s.io/kubernetes/pkg/kubelet/qos"
+)
+
+func init() {
+	// Register the AddToleration admission controller.
+	admission.RegisterPlugin("AddToleration", func(client clientset.Interface, config io.Reader) (admission.Interface, error) {
+		return NewAddToleration(), nil
+	})
+}
+
+// addToleration implements admission.Interface which adds tolerations to pods
+// which belong to Burstable or Guaranteed QoS class.
+// The toleration <"hponly","true",api.TaintEffectNoSchedule> is added.
+type addToleration struct {
+	*admission.Handler
+}
+
+// Admit adds tolerations to pods belonging to Burstable and Guaranteed QoS class.
+func (a *addToleration) Admit(attributes admission.Attributes) (err error) {
+	// Ignore all calls to subresources or resources other than pods.
+	if len(attributes.GetSubresource()) != 0 || attributes.GetResource().GroupResource() != api.Resource("pods") {
+		return nil
+	}
+	pod, ok := attributes.GetObject().(*api.Pod)
+	if !ok {
+		return apierrors.NewBadRequest("Resource was marked with kind Pod but was unable to be converted.")
+	}
+
+	// Only add tolerations if the pod belongs to Burstable or Guaranteed QoS class.
+	if qos.GetPodQOS(pod) == qos.Burstable || qos.GetPodQOS(pod) == qos.Guaranteed {
+		// Initialize annotations if it does not exist.
+		if pod.Annotations == nil {
+			pod.Annotations = make(map[string]string)
+		}
+
+		// If there are no tolerations then add our tolerations directly.
+		// Otherwise reorganize the existing tolerations to include the new toleration.
+		if pod.Annotations[api.TolerationsAnnotationKey] == "" {
+			tolerationsData, err := json.Marshal([]api.Toleration{
+				{
+					Key:    "hponly",
+					Value:  "true",
+					Effect: api.TaintEffectNoSchedule,
+				},
+			})
+			if err != nil {
+				glog.Errorf("Cannot decode new toleration value: %v", err)
+				return err
+			}
+			pod.Annotations[api.TolerationsAnnotationKey] = string(tolerationsData)
+		} else {
+			var taints []api.Toleration
+			err := json.Unmarshal([]byte(pod.Annotations[api.TolerationsAnnotationKey]), &taints)
+			if err != nil {
+				glog.Errorf("Cannot decode exisiting node annotations: %v", err)
+				return err
+			}
+
+			exists := false
+			for idx, taint := range taints {
+				if taint.Key == "hponly" {
+					taints[idx].Value = "true"
+					exists = true
+				}
+			}
+
+			if !exists {
+				newTaint := api.Toleration{
+					Key:    "hponly",
+					Value:  "true",
+					Effect: api.TaintEffectNoSchedule,
+				}
+				taints = append(taints, newTaint)
+			}
+
+			tolerationsData, err := json.Marshal(taints)
+			if err != nil {
+				glog.Errorf("Cannot encode new toleration value: %v", err)
+				return err
+			}
+
+			pod.Annotations[api.TolerationsAnnotationKey] = string(tolerationsData)
+		}
+	}
+	return nil
+}
+
+// NewAddToleration creates a new add toleration admission controller handler.
+func NewAddToleration() admission.Interface {
+	return &addToleration{
+		Handler: admission.NewHandler(admission.Create, admission.Update),
+	}
+}
